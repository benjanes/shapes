function genTokenData(t){let e={},n="0x";for(var s=0;s<64;s++)n+=Math.floor(16*Math.random()).toString(16);return e.hash=n,e.tokenId=(1e6*t+Math.floor(1e3*Math.random())).toString(),e}let tokenData=genTokenData(123);const seed=tokenData.hash;class Random{constructor(){this.useA=!1;let t=function(t){let e=parseInt(t.substr(0,8),16),n=parseInt(t.substr(8,8),16),s=parseInt(t.substr(16,8),16),r=parseInt(t.substr(24,8),16);return function(){let t=((e|=0)+(n|=0)|0)+(r|=0)|0;return r=r+1|0,e=n^n>>>9,n=(s|=0)+(s<<3)|0,s=(s=s<<21|s>>>11)+t|0,(t>>>0)/4294967296}};this.prngA=new t(tokenData.hash.substr(2,32)),this.prngB=new t(tokenData.hash.substr(34,32));for(let t=0;t<1e6;t+=2)this.prngA(),this.prngB()}dec(){return this.useA=!this.useA,this.useA?this.prngA():this.prngB()}}const R=new Random,[p1,p2,p3,p4,p5,p6,p7,p8]=Array.from({length:8},()=>R.dec()),canvas=document.querySelector("canvas"),ctx=canvas.getContext("2d"),targetWidth=5*canvas.offsetWidth;canvas.width=targetWidth,canvas.height=targetWidth;const yMultiplier=p3<.5?p3/.5*.4+.6:(p3-.5)/.5*.3+1.05,xExponent=.004*p4+.999,width=3e3,height=3e3,scale=targetWidth/3e3,fill1=ctx.createLinearGradient(3e3*p4,3e3*p1,3e3*p3,3e3*p2),fill2=ctx.createLinearGradient(3e3*p4,0,3e3*p3,3e3);fill1.addColorStop(0,"#222"),fill1.addColorStop(1,`rgb(${parseInt(255*p5)},${parseInt(100*p5)},0)`),fill2.addColorStop(0,"rgba(0,0,0,0)"),fill2.addColorStop(1,`rgba(${parseInt(100*p7)},0,${parseInt(100*p8)}, 0.5)`),ctx.fillStyle=fill1,ctx.fillRect(0,0,targetWidth,targetWidth),ctx.fillStyle=fill2,ctx.fillRect(0,0,targetWidth,targetWidth);const baseLineWidth=1*scale,yAdjusts=[-1055,-834,-509,-40,650];for(let t=0;t<40;t++){const e=t/40*.04,n=.001*t,s=(.45*p5+.05)*t;yAdjusts.forEach(t=>{fUpTheLines({pts:[{x:1500+0*n,y:1500+t},{x:1500+n,y:1500+t+s}].map(t=>({...t,lineWidth:baseLineWidth,opacity:e})),rgb:"255,255,255",startSegs:4,segs:6})})}function fUpTheLines({pts:t,rgb:e,startSegs:n,segs:s}){const r=[new Polyline(t,ctx,{isClosed:!0,tension:.01,numSegments:n})];for(let t=1;t<5;t++){const e=nextPointsFromPreviousPoly(r[t-1]);r.push(new Polyline(e,ctx,{isClosed:!0,tension:p1,numSegments:s}))}r.forEach((t,n)=>n&&t.draw({rgb:e,scale:scale}))}function nextPointsFromPreviousPoly(t){const e=t.curvePoints[0].lineWidth/(.5+p2/2);return t.curvePoints.reduce((t,n,s)=>{const r=rotatePoint({x:1*Math.pow(n.x,xExponent),y:n.y*yMultiplier},n.normal,n);return t.concat({...r,lineWidth:e,opacity:n.opacity})},[])}function rotatePoint(t,e,n){const s=Math.cos(e),r=Math.sin(e),a=t.x-n.x,o=t.y-n.y;return{x:s*a-r*o+n.x,y:s*o+r*a+n.y}}